{"name":"Pj1 growinglines","tagline":"This Course is about generative Design and generative Algorithms. The work arose with the help of processing in the Course  Input/Output of the FH Potsdam. ","body":"#PRJ1_GrowingLines\r\nIn the first part of the course we learned what algorythms are, and how they are structured. We also learned the basics of the programming language Processing and lerned what generative Design is.\r\n##IDEA  \r\nOur first contact with Programming language we got with the language we already learned: Our own verbal language. The exercise was to simply (or event harder then thought)  formulate an algorythm that later had to be solved by the coursemates. After several changes in details and complexity the final code looked like this (german):\r\n\r\n\t1. Wähle eine Farbe danach, wie warm du dich im Moment fühlst (zB. eine warme Farbe, Orange oder Gelb, wenn es dir Wohlig warm ist)\r\n\t2. Male damit einen Punkt in die Mitte des Blattes \r\n\t3. Ziehe von diesem Punkt vier 1,5 cm lange, Linien nach oben, nach unten, nach rechts und nach links.\r\n\t4. Zeichne an das Ende der Linien eine weitere Linie, die im 90 Gradwinkel nach rechts und nach links verläuft.\r\n\t5. Wenn du lieber im Süden Urlaub machen würdest, als im Norden, wähle nun die nächst wärmere Farbe der Kreiden, sonst die nächst kühlere\r\n\t6. Zeichne mit dieser Farbe 8 neue Linien mit ca. 1 cm Länge an die  Enden deines Konstruktes, wobei diese in Richtung des nächsten Blattrandes verlaufen.\r\n\t7. Du hast jetzt 8 Enden.\r\n\t8. Schaue auf die Uhr. \r\n\t\t- Wenn es vor 12 Uhr ist, zeichne von jedem Ende eine Linie nach links. \r\n\t\t- Wenn es zwischen 12 und 16 Uhr ist, zeichne Linien nach rechts und nach Links\r\n\t\t- Wenn es nach 16 Uhr ist, zeichne eine Linie nach rechts\r\n\t9. Schaue auf die Farbe deines Oberteils. Wenn du sie als kühl empfindest, nehme den nächst wärmeren Farbton der Kreiden. Wenn du die Farbe als warm empfindest, nehme den nächst kühleren Farbton\r\n\t10. Zeichne mit diesen wieder Linien mit ca 1cm von den Enden in Richtung Blattrand\r\n\t11. Wenn du jetzt 8 Enden hast, ziehe von jedem ende einen strich nach rechts und nach links. Wenn du 16 Enden hast kannst du wählen: Ziehe einen Strich nach rechts, nach links oder nach rechts und links. \r\n\t12. Nehme die Farbe, die dir am besten gefällt. Zeichne damit  nun wieder von den Enden ausgehend Linien zum Blattrand. Mache sie so lange, bis du den Blattrand erreichst.\r\n\t13. Fahre beginnend in der Mitte jeden Strang mit dem Finger nach, und verschmiere die Kreide so ein wenig.\r\n\t14. Vielen Dank für deine Hilfe!\r\n\r\n**results:**\r\n![2](https://dl-web.dropbox.com/get/Public%20Stuff/PJ1_12.png?_subject_uid=32925921&w=AAAO98pq8NeCvidDnWvwiOeNgFgAH6BbNiqJvVkeN-DlzQ)\r\n![3](https://dl-web.dropbox.com/get/Public%20Stuff/PJ1_13.png?_subject_uid=32925921&w=AAC1kpe0MvSiEWVq_GcRv4DqgzFsTXaUasKiUsyFTPaH0g)\r\n![3](https://dl-web.dropbox.com/get/Public%20Stuff/PJ1_14.png?_subject_uid=32925921&w=AABawErjvOTDxXTIdMZHqTYc5fKh_JhbjaQos1oMwg4bmw)\r\n![4](https://dl-web.dropbox.com/get/Public%20Stuff/PJ1_15.png?_subject_uid=32925921&w=AAB6GNpN2rrLQMoJOmmMxKOhTK8MBDPRvXFxqy_hBR0qtA)\r\n![5](https://dl-web.dropbox.com/get/Public%20Stuff/PJ1_18.png?_subject_uid=32925921&w=AAD5_SlRv57lFN1iZFmS6ytIIyKX2Pjbe83vhNU3G4-cHg)\r\n##REALISATION - Software\r\nThe next exercise was to translate ower human code into processing. Fabian Moron Zirfás, our tutor, gave us some basics and much help. \r\nI really was pretty confident with myself, because processing was the first programming  language I ever used at this moment, and I was happy to see, that I could at least do something with it, even if it was far away, from what I wanted to do.  After some hours of pure processing practise, I decided to look for a way to translate my human code into processing. I built some Versions with Recursion with the help of the book \"Generative Gestaltung\" of Hartmut Bohnacker, Benedikt Groß and Julia Laub.  \r\nOn my way towards goal I found a really nice Idea, which I prefered compared to the Recursion-Version of my code: A straight line would run over the screen, it would always \"stop\"  after a certain length, choose a random direction in the angle of 90° including the one it came from, and then go on towards this direction.   \r\n**My first code looked like this:**  \r\n[![firstCode2D](https://dl-web.dropbox.com/get/Public%20Stuff/PJ1_21.png?_subject_uid=32925921&w=AACV_8ReUbz2NLmEIHTZHyKdUjyjAiH8rg8J3vxsu7CykA)](https://vimeo.com/125339378)\r\n\t  \r\n\t \r\n\t  float radius = 20;\r\n\t  \r\n\t  //on field - positions\r\n\t  float x1, x2, x3, x4;\r\n\t  float y1, y2, y3, y4;\r\n\t  float OLDx1, OLDx2, OLDx3, OLDx4;\r\n\t  float OLDy1, OLDy2, OLDy3, OLDy4;\r\n\t  \r\n\t  //colors \r\n\t  int r1=(int)random(0,255);\r\n\t  int g1=(int)random(0,255);\r\n\t  int b1=(int)random(0,255);\r\n\t  int r2=(int)random(0,255);\r\n\t  int g2=(int)random(0,255);\r\n\t  int b2=(int)random(0,255);\r\n\t  int r3=(int)random(0,255);\r\n\t  int g3=(int)random(0,255);\r\n\t  int b3=(int)random(0,255);\r\n\t  int r4=(int)random(0,255);\r\n\t  int g4=(int)random(0,255);\r\n\t  int b4=(int)random(0,255);\r\n\r\n\t  void setup(){\r\n\t  size(800,800);\r\n\t  background(255);\r\n\t  x1 = x2 = x3 = x4 = width/2;\r\n\t  y1 = y2 = y3 = y4 = height/2;\r\n\t  OLDx1 = OLDx2 = OLDx3 = OLDx4 = x1;\r\n\t  OLDy1 = OLDy2 = OLDy3 = OLDy4 = y1;\r\n\t  frameRate(60);\r\n\t  }\r\n\t  \r\n\t  void draw()\r\n\t  {\r\n\t  //define new angle\r\n\t  float angle =(TWO_PI/4) * floor(random(-4,4));\r\n\t  x1 += cos(angle)*radius;\r\n\t  y1 += sin(angle)* radius;\r\n\t  angle =(TWO_PI/4) * floor(random(-4,4));\r\n\t  x2 += cos(angle)*radius;\r\n\t  y2 += sin(angle)* radius;\r\n\t  angle =(TWO_PI/4) * floor(random(-4,4));\r\n\t  x3 += cos(angle)*radius;\r\n\t  y3 += sin(angle)* radius;\r\n\t  angle =(TWO_PI/4) * floor(random(-4,4));\r\n\t  x4 += cos(angle)*radius;\r\n\t  y4 += sin(angle)* radius;\r\n\t  \r\n\t  //prohibit offscreen points\r\n\t  if (x1<0 || x1>width || y1<0 || y1>width){\r\n\t  x1 = OLDx1;\r\n\t  y1 = OLDy1;\r\n\t  }  \r\n\t  if (x2<0 || x2>width || y2<0 || y2>width){\r\n\t  x2 = OLDx2;\r\n\t  y2 = OLDy2;\r\n\t  }\r\n\t  if (x3<0 || x3>width || y3<0 || y3>width){\r\n\t  x3 = OLDx3;\r\n\t  y3 = OLDy3;\r\n\t  }\r\n\t  if (x4<0 || x4>width || y4<0 || y4>width){\r\n\t  x4 = OLDx4;\r\n\t  y4 = OLDy4;\r\n\t  }\r\n\t  \r\n\t   //set angle points\r\n\t  strokeWeight(4);\r\n\t  stroke(r1, g1, b1);\r\n\t  point(x1,y1);\r\n\t  stroke(r2, g2, b2);\r\n\t  point(x2,y2);\r\n\t  stroke(r3, g3, b3);\r\n\t  point(x3,y3);\r\n\t  stroke(r4, g4, b4);\r\n\t  point(x4,y4);\r\n\t  \r\n\t  //draw lines\r\n\t  strokeWeight(2);\r\n\t  stroke(r1, g1, b1);\r\n\t  line(x1,y1,OLDx1, OLDy1);\r\n\t  stroke(r2, g2, b2);\r\n\t  line(x2,y2,OLDx2, OLDy2);\r\n\t  stroke(r3, g3, b3);\r\n\t  line(x3,y3,OLDx3, OLDy3);\r\n\t  stroke(r4, g4, b4);\r\n\t  line(x4,y4,OLDx4, OLDy4);\r\n\t  \r\n\t  //save old points for backup  \r\n\t  OLDx1 = x1;\r\n\t  OLDy1 = y1;\r\n\t  OLDx2 = x2;\r\n\t  OLDy2 = y2;\r\n\t  OLDx3 = x3;\r\n\t  OLDy3 = y3;\r\n\t  OLDx4 = x4;\r\n\t  OLDy4 = y4;  \r\n\t  } \r\n\t  \r\nAlthough I was pretty proud of my first solution I still didn't find it visually attractive all times you started it. The colors where to random, and often didn't fit to each other, so I decided to specify four colors. \r\nAlso I found out that the occuring pictures often looked better, when the starting points of the four colors where in the edges.  After some rework time, my code Looked like this:  \r\n\r\n**the final 2D Version:**  \r\n  [![finalVersion](https://dl-web.dropbox.com/get/Public%20Stuff/PJ1_22.png?_subject_uid=32925921&w=AABeDtZnBQDd4eowidzl3jseuFvDDTYGzAaQSyV_k5xctw)](https://vimeo.com/125339379)\r\n\t  \r\n\t  float radius = 30;\r\n\t  \r\n\t  //on field positions\r\n\t  float x1, x2, x3, x4;\r\n\t  float y1, y2, y3, y4;\r\n\t  float OLDx1, OLDx2, OLDx3, OLDx4;\r\n\t  float OLDy1, OLDy2, OLDy3, OLDy4;\r\n\t  \r\n\t  //colors \r\n\t  int r1 = 255;\r\n\t  int g1 = 0;\r\n\t  int b1 = 44;\r\n\t  int r2 = 10;\r\n\t  int g2 = 202;\r\n\t  int b2 = 255;\r\n\t  int r3 = 255;\r\n\t  int g3 = 49;\r\n\t  int b3 = 3;\r\n\t  int r4 = 0;\r\n\t  int g4 = 255;\r\n\t  int b4 = 214;\r\n\r\n\t  void setup(){\r\n\t  size(800,800);\r\n\t  background(0);\r\n\t  x1 = x3 = 0;\r\n\t  x2 = x4 = width;\r\n\t  y1 = y2 = 0;\r\n\t  y3 = y4 = height;\r\n\t  OLDx1 = OLDx3 = x1;\r\n\t  OLDx2 = OLDx4 = x2;\r\n\t  OLDy1 = OLDy2 = y1;\r\n\t  OLDy3 = OLDy4 = y3;\r\n\t  frameRate(60);\r\n\t  }\r\n\t  \r\n\t  \r\n\t  void draw()\r\n\t  {\r\n\t  \r\n\t  //define new angle\r\n\t  float angle =(TWO_PI/4) * floor(random(-4,4));\r\n\t  x1 += cos(angle)*radius;\r\n\t  y1 += sin(angle)* radius;\r\n\t  angle =(TWO_PI/4) * floor(random(-4,4));\r\n\t  x2 += cos(angle)*radius;\r\n\t  y2 += sin(angle)* radius;\r\n\t  angle =(TWO_PI/4) * floor(random(-4,4));\r\n\t  x3 += cos(angle)*radius;\r\n\t  y3 += sin(angle)* radius;\r\n\t  angle =(TWO_PI/4) * floor(random(-4,4));\r\n\t  x4 += cos(angle)*radius;\r\n\t  y4 += sin(angle)* radius;\r\n\t  \r\n\t  //prohibit offscreen points\r\n\t  if (x1<0 || x1>width || y1<0 || y1>width){\r\n\t  x1 = OLDx1;\r\n\t  y1 = OLDy1;\r\n\t  }  \r\n\t  if (x2<0 || x2>width || y2<0 || y2>width){\r\n\t  x2 = OLDx2;\r\n\t  y2 = OLDy2;\r\n\t  }\r\n\t  if (x3<0 || x3>width || y3<0 || y3>width){\r\n\t  x3 = OLDx3;\r\n\t  y3 = OLDy3;\r\n\t  }\r\n\t  if (x4<0 || x4>width || y4<0 || y4>width){\r\n\t  x4 = OLDx4;\r\n\t  y4 = OLDy4;\r\n\t  }\r\n\t  \r\n\t  //draw lines\r\n\t  strokeWeight(2);\r\n\t  stroke(r1, g1, b1);\r\n\t  line(x1,y1,OLDx1, OLDy1);\r\n\t  stroke(r2, g2, b2);\r\n\t  line(x2,y2,OLDx2, OLDy2);\r\n\t  stroke(r3, g3, b3);\r\n\t  line(x3,y3,OLDx3, OLDy3);\r\n\t  stroke(r4, g4, b4);\r\n\t  line(x4,y4,OLDx4, OLDy4);\r\n\t  \r\n\t //set angle points\r\n\t  strokeWeight(4);\r\n\t  stroke(r1, g1, b1);\r\n\t  point(x1,y1);\r\n\t  stroke(r2, g2, b2);\r\n\t  point(x2,y2);\r\n\t  stroke(r3, g3, b3);\r\n\t  point(x3,y3);\r\n\t  stroke(r4, g4, b4);\r\n\t  point(x4,y4);\r\n\t  \r\n\t  //save old points for backup  \r\n\t  OLDx1 = x1;\r\n\t  OLDy1 = y1;\r\n\t  OLDx2 = x2;\r\n\t  OLDy2 = y2;\r\n\t  OLDx3 = x3;\r\n\t  OLDy3 = y3;\r\n\t  OLDx4 = x4;\r\n\t  OLDy4 = y4;  \r\n\t  } \r\n\r\nMy 2D solution was now done, and as you would eventually now spaculate, I took the opportunity to built a 3D Version.  \r\nIn the threedimensional solution decreased the lines to 1 single line, after I recognized, that 4 lines would be way to much to differenciate because the third dimension gave the construct a pretty high amount of visual complexity compared to the erlier version.  \r\nFor an improved visual clarity I developed a kind of 3rd-dimension color: As the line moves in the z-dimension, the color gets warmer (nearer) and colder (further). The color scheme ranges from dark blue to red.  \r\n\r\n**the final 3D Version:**  \r\n  [![3D](https://www.dropbox.com/s/r97e02w2ovwbx4q/PJ1_11.png?dl=0)](https://vimeo.com/125339380)\r\n\r\n\t//root size\r\n\tfloat radius = 50;\r\n\t  float x, y, z;\r\n\t  float OLDx, OLDy, OLDz;\r\n\r\n\t  //start color\r\n\t  int r=100;\r\n\t  int g=0;\r\n\t  int b=100;\r\n\r\n\t  void setup(){\r\n\t  size(1200,1200,P3D);\r\n\t  background(0);\r\n\t  x = width/2;\r\n\t  y =height/2+200;\r\n\t  z = 200;\r\n\t  OLDx = x;\r\n\t  OLDy = y;\r\n\t  OLDz = z;\r\n\t  frameRate(60);\r\n\t  }\r\n\t  \r\n\t  void draw(){\r\n\t  //point of view\r\n\t  rotateX(-0.7);\r\n\t  rotateY(0.34);  \r\n\t  \r\n\t  //draw\r\n\t  fill(r,g,b);\r\n\t  stroke(r+50,g+50,b+50);\r\n\t  strokeWeight(4);\r\n\t  point(x,y,z);\r\n\t  stroke(r,g,b);\r\n\t  strokeWeight(2);\r\n\t  beginShape();\r\n\t  vertex(OLDx,OLDy,OLDz);\r\n\t  vertex(x, y, z);\r\n\t  \r\n\t  //backup old values\r\n\t  OLDx = x;\r\n\t  OLDy = y;\r\n\t  OLDz = z;\r\n\t  \r\n\t  //define new x, y, z\r\n\t  int q = (int)random(12);\r\n\t  if(q==1){\r\n\t  x = x+radius;\r\n\t  }\r\n\t  if(q==2){\r\n\t  x = x-radius;\r\n\t  }\r\n\t  if(q==3){\r\n\t  y = y+radius;\r\n\t  }\r\n\t  if(q==4){\r\n\t  y = y-radius;\r\n\t  } \r\n\t  if(q==5){\r\n\t  z = z+radius/2;\r\n\t  r=r+30;\r\n\t  b = b-30;\r\n\t  }\r\n\t  if(q==6){\r\n\t  z = z-radius;\r\n\t  b=b+30;\r\n\t  r = r-30;\r\n\t  } \r\n\t  \r\n\t  //prohibit vertex to run out of screen\r\n\t  if(y<0 || y>height||x<0 || x>width||z<0 || z>height/4){\r\n\t  y = OLDy;\r\n\t  x = OLDx;\r\n\t  z = OLDz;\r\n\t  \r\n\t  //prohibit colorvalue to run out of range\r\n\t  }\r\n\t  if(r>255){\r\n\t  r=255;\r\n\t  }\r\n\t  if(b>255){\r\n\t  b=255;\r\n\t  }\r\n\r\n\t  vertex(x, y, z);\r\n\t  endShape(); \r\n\t  point(x,y);\r\n\t  if(mousePressed){saveFrame();}\r\n\t}   \r\n\r\n##FINISH\r\nFor the final presentation we also had the exercise to find an application for our programmed algorythm. This could be in form of an object or a 2D print. The goal was to get the code into the real world again, after we transfered it in computer-understandable language.  \r\nI had the Idea to use the pattern generated in the 2D-Version in my Code to integrate it in a Lamp.  First I built a construct with wood, which was drilled and then interwoven with fishing line. Then I used wool to generate the pattern in the with boulter generated network. \r\nAt the end I covered the free areas with black carton and recessed a lightbulb and composure.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}